{
    "docs": [
        {
            "location": "/",
            "text": "lua-TestMore\n\n\n\n\nOverview\n\n\nlua-TestMore is a port of the Perl5 module\n\nTest::More\n.\n\n\nIt uses the\n\nTest Anything Protocol\n\nas output, that allows a compatibility with the Perl QA ecosystem.\nFor example,\n\nprove\n\na basic CLI, or\n\nSmolder\n\na Web-based Continuous Integration Smoke Server.\n\n\nIt's an extensible framework.\n\n\nIt allows a simple and efficient way to write tests (without OO style).\n\n\nSome tests could be marked as \nTODO\n or \nskipped\n.\n\n\nErrors could be fully checked with \nerror_like()\n.\n\n\nIt supplies a Test Suite for Lua itself.\n\n\nReferences\n\n\nIan Langworth, chromatic,\n\nPerl Testing\n\nO'Reilly, 2005\n\n\nStatus\n\n\nlua-TestMore is in beta stage.\n\n\nIt's developed for Lua 5.1, 5.2 & 5.3.\n\n\nDownload\n\n\nlua-TestMore source can be downloaded from\n\nGitHub\n.\n\n\nInstallation\n\n\nThe easiest way to install lua-TestMore is to use LuaRocks:\n\n\nluarocks install lua-testmore\n\n\n\n\nor manually, with:\n\n\nmake install\n\n\n\n\nThe Lua Test Suite (5.1, 5.2 & 5.3)\n\n\nThis suite is usable with :\n\n\n\n\nthe standard \nlua\n,\n\n\nLuaJIT\n,\n\n\n...\n\n\n\n\nIt gives this \ncoverage\n with Lua 5.1.5,\nthis \ncoverage\n with Lua 5.2.4\nand this \ncoverage\n with Lua 5.3.4.\n\n\nCopyright and License\n\n\nCopyright &copy 2009-2016 Fran\u00e7ois Perrad\n\n\n\n\n\nThis library is licensed under the terms of the MIT/X11 license,\nlike Lua itself.",
            "title": "Home"
        },
        {
            "location": "/#lua-testmore",
            "text": "",
            "title": "lua-TestMore"
        },
        {
            "location": "/#overview",
            "text": "lua-TestMore is a port of the Perl5 module Test::More .  It uses the Test Anything Protocol \nas output, that allows a compatibility with the Perl QA ecosystem.\nFor example, prove \na basic CLI, or Smolder \na Web-based Continuous Integration Smoke Server.  It's an extensible framework.  It allows a simple and efficient way to write tests (without OO style).  Some tests could be marked as  TODO  or  skipped .  Errors could be fully checked with  error_like() .  It supplies a Test Suite for Lua itself.",
            "title": "Overview"
        },
        {
            "location": "/#references",
            "text": "Ian Langworth, chromatic, Perl Testing \nO'Reilly, 2005",
            "title": "References"
        },
        {
            "location": "/#status",
            "text": "lua-TestMore is in beta stage.  It's developed for Lua 5.1, 5.2 & 5.3.",
            "title": "Status"
        },
        {
            "location": "/#download",
            "text": "lua-TestMore source can be downloaded from GitHub .",
            "title": "Download"
        },
        {
            "location": "/#installation",
            "text": "The easiest way to install lua-TestMore is to use LuaRocks:  luarocks install lua-testmore  or manually, with:  make install",
            "title": "Installation"
        },
        {
            "location": "/#the-lua-test-suite-51-52-53",
            "text": "This suite is usable with :   the standard  lua ,  LuaJIT ,  ...   It gives this  coverage  with Lua 5.1.5,\nthis  coverage  with Lua 5.2.4\nand this  coverage  with Lua 5.3.4.",
            "title": "The Lua Test Suite (5.1, 5.2 &amp; 5.3)"
        },
        {
            "location": "/#copyright-and-license",
            "text": "Copyright &copy 2009-2016 Fran\u00e7ois Perrad   This library is licensed under the terms of the MIT/X11 license,\nlike Lua itself.",
            "title": "Copyright and License"
        },
        {
            "location": "/testmore/",
            "text": "Test.More\n\n\n\n\nReference\n\n\nAll functions are injected in the global environment \n_G\n.\n\n\nplan( arg )\n\n\nplan(2)\n\npass \"one\"\npass \"two\"\n\n\n\n\ngives\n\n\n1..2\nok 1 - one\nok 2 - two\n\n\n\n\ndone_testing( num_tests )\n\n\nplan 'no_plan'\n\npass \"one\"\npass \"two\"\ndone_testing()\n\n\n\n\ngives\n\n\nok 1 - one\nok 2 - two\n1..2\n\n\n\n\nskip_all( reason )\n\n\nif everything_looks_good then\n    plan(7)\nelse\n    skip_all \"looks bad\"\nend\n\n\n\n\ngives\n\n\n1..0 # SKIP looks bad\n\n\n\n\nBAIL_OUT( reason )\n\n\nplan(7)\n\nif not require_ok 'MyApp' then\n    BAIL_OUT \"no MyApp\"\nend\n\n\n\n\ngives\n\n\n1..7\nnot ok 1 - require 'MyApp'\n#     module 'MyApp' not found:\n#       no field package.preload['MyApp']\n#       no file '.\\MyApp.lua'\n#       ...\nBail out!  no MyApp\n\n\n\n\nand breaks the execution of \nprove\n.\n\n\nsubtest( name, func )\n\n\nplan(3)\npass \"First test\"\nsubtest('An example subtest', function ()\n    plan(2)\n    pass \"This is a subtest\"\n    pass \"So is this\"\nend)\npass \"Third test\"\n\n\n\n\ngives\n\n\n1..3\nok 1 - First test\n# Subtest: An example subtest\n    1..2\n    ok 1 - This is a subtest\n    ok 2 - So is this\nok 2 - An example subtest\nok 3 - Third test\n\n\n\n\nok( test [, name] )\n\n\nnok( test [, name] )\n\n\nis( got, expected [, name] )\n\n\nisnt( got, expected [, name] )\n\n\nlike( got, pattern [, name] )\n\n\nunlike( got, pattern [, name] )\n\n\ncmp_ok( this, op, that [, name] )\n\n\ntype_ok( val, t [, name] )\n\n\npass( name )\n\n\nfail( name )\n\n\nrequire_ok( mod )\n\n\neq_array( got, expected [, name] )\n\n\nis_deeply( got, expected [, name] )\n\n\nerror_is( code [, params_array], expected [, name] )\n\n\nerror_like( code [, params_array], pattern [, name] )\n\n\nlives_ok( code [, params_array] [, name] )\n\n\ndiag( msg )\n\n\nnote( msg )\n\n\nskip( reason [, count] )\n\n\nplan(4)\n\npass \"one\"\n\nif true then\n    skip(\"here, segfault\", 2)\nelse\n    fail \"two\"\n    fail \"three\"\nend\n\npass \"four\"\n\n\n\n\ngives\n\n\n1..4\nok 1 - one\nok 2 - # skip here, segfault\nok 3 - # skip here, segfault\nok 4 - four\n\n\n\n\ntodo_skip( reason [, count] )\n\n\nplan(3)\n\npass \"one\"\n\nif true then\n    todo_skip \"here, segfault\"\nelse\n    fail \"two\"\nend\n\npass \"three\"\n\n\n\n\ngives\n\n\n1..3\nok 1 - one\nnot ok 2 - # TODO & SKIP here, segfault\nok 3 - three\n\n\n\n\nskip_rest( reason )\n\n\nplan(3)\n\nif not require_ok 'MyApp' then\n    skip_rest \"no MyApp\"\n    os.exit()\nend\n\npass \"two\"\npass \"three\"\n\n\n\n\ngives\n\n\n1..3\nnot ok 1 - require 'MyApp'\n#     module 'MyApp' not found:\n#       no field package.preload['MyApp']\n#       no file '.\\MyApp.lua'\n#       ...\nok 2 - # skip no MyApp\nok 3 - # skip no MyApp\n\n\n\n\ntodo( reason [, count] )\n\n\nplan(4)\n\npass \"one\"\n\ntodo( \"not yet implemented\", 2 )\nfail \"two\"\nfail \"three\"\n\npass \"four\"\n\n\n\n\ngives\n\n\n1..4\nok 1 - one\nnot ok 2 - two # TODO # not yet implemented\nnot ok 3 - three # TODO # not yet implemented\nok 4 - four\n\n\n\n\nExamples\n\n\n-- 99example.t\n#!/usr/bin/lua\nrequire 'Test.More'\n\nplan(9)\n\nok(true, \"true\")\nok(1, \"1 is true\")\nnok(false, \"false\")\nnok(nil, \"nil is false\")\n\nis(1 + 1, 2, \"addition\")\n\nlike(\"with aaa\", 'a', \"pattern matches\")\nunlike(\"with aaa\", 'b', \"pattern doesn't match\")\n\nerror_like([[error 'MSG']], '^[^:]+:%d+: MSG', \"loadstring error\")\nerror_is(error, { 'MSG' }, 'MSG', \"function error with param\")\n\n\n\n\n$ lua 99example.t\n1..9\nok 1 - true\nok 2 - 1 is true\nok 3 - false\nok 4 - nil is false\nok 5 - addition\nok 6 - pattern matches\nok 7 - pattern doesn't match\nok 8 - loadstring error\nok 9 - function error with param\n\n\n\n\nNow, with \nprove\n.\n\n\n$ prove 99example.t\n99example.t .. ok\nAll tests successful.\nFiles=1, Tests=9,  0 wallclock secs ( 0.05 usr +  0.20 sys =  0.25 CPU)\nResult: PASS\n\n\n\n\nIf your continuous integration tool\n(for example, \nJenkins\n)\nrequires the JUnix XML format.\n\n\n$ prove --formatter=TAP::Formatter::JUnit 99example.t\n<testsuites>\n  <testsuite failures=\"0\"\n             errors=\"0\"\n             tests=\"9\"\n             name=\"test_99example_t\">\n    <testcase name=\"1 - true\"></testcase>\n    <testcase name=\"2 - 1 is true\"></testcase>\n    <testcase name=\"3 - false\"></testcase>\n    <testcase name=\"4 - nil is false\"></testcase>\n    <testcase name=\"5 - addition\"></testcase>\n    <testcase name=\"6 - pattern matches\"></testcase>\n    <testcase name=\"7 - pattern doesn't match\"></testcase>\n    <testcase name=\"8 - loadstring error\"></testcase>\n    <testcase name=\"9 - function error with param\"></testcase>\n    <system-out><![CDATA[1..9\nok 1 - true\nok 2 - 1 is true\nok 3 - false\nok 4 - nil is false\nok 5 - addition\nok 6 - pattern matches\nok 7 - pattern doesn't match\nok 8 - loadstring error\nok 9 - function error with param\n]]></system-out>\n    <system-err></system-err>\n  </testsuite>\n</testsuites>\n\n\n\n\nIf your results must be stored first, and processed after.\n\n\n$ lua 99example.t > 99example.tap\n$ prove --source=TAP::Parser::SourceHandler::RawTAP 99example.tap\n99example.tap .. ok\nAll tests successful.\nFiles=1, Tests=9,  0 wallclock secs ( 0.02 usr +  0.04 sys =  0.06 CPU)\nResult: PASS",
            "title": "Test.More"
        },
        {
            "location": "/testmore/#testmore",
            "text": "",
            "title": "Test.More"
        },
        {
            "location": "/testmore/#reference",
            "text": "All functions are injected in the global environment  _G .",
            "title": "Reference"
        },
        {
            "location": "/testmore/#plan-arg",
            "text": "plan(2)\n\npass \"one\"\npass \"two\"  gives  1..2\nok 1 - one\nok 2 - two",
            "title": "plan( arg )"
        },
        {
            "location": "/testmore/#done_testing-num_tests",
            "text": "plan 'no_plan'\n\npass \"one\"\npass \"two\"\ndone_testing()  gives  ok 1 - one\nok 2 - two\n1..2",
            "title": "done_testing( num_tests )"
        },
        {
            "location": "/testmore/#skip_all-reason",
            "text": "if everything_looks_good then\n    plan(7)\nelse\n    skip_all \"looks bad\"\nend  gives  1..0 # SKIP looks bad",
            "title": "skip_all( reason )"
        },
        {
            "location": "/testmore/#bail_out-reason",
            "text": "plan(7)\n\nif not require_ok 'MyApp' then\n    BAIL_OUT \"no MyApp\"\nend  gives  1..7\nnot ok 1 - require 'MyApp'\n#     module 'MyApp' not found:\n#       no field package.preload['MyApp']\n#       no file '.\\MyApp.lua'\n#       ...\nBail out!  no MyApp  and breaks the execution of  prove .",
            "title": "BAIL_OUT( reason )"
        },
        {
            "location": "/testmore/#subtest-name-func",
            "text": "plan(3)\npass \"First test\"\nsubtest('An example subtest', function ()\n    plan(2)\n    pass \"This is a subtest\"\n    pass \"So is this\"\nend)\npass \"Third test\"  gives  1..3\nok 1 - First test\n# Subtest: An example subtest\n    1..2\n    ok 1 - This is a subtest\n    ok 2 - So is this\nok 2 - An example subtest\nok 3 - Third test",
            "title": "subtest( name, func )"
        },
        {
            "location": "/testmore/#ok-test-name",
            "text": "",
            "title": "ok( test [, name] )"
        },
        {
            "location": "/testmore/#nok-test-name",
            "text": "",
            "title": "nok( test [, name] )"
        },
        {
            "location": "/testmore/#is-got-expected-name",
            "text": "",
            "title": "is( got, expected [, name] )"
        },
        {
            "location": "/testmore/#isnt-got-expected-name",
            "text": "",
            "title": "isnt( got, expected [, name] )"
        },
        {
            "location": "/testmore/#like-got-pattern-name",
            "text": "",
            "title": "like( got, pattern [, name] )"
        },
        {
            "location": "/testmore/#unlike-got-pattern-name",
            "text": "",
            "title": "unlike( got, pattern [, name] )"
        },
        {
            "location": "/testmore/#cmp_ok-this-op-that-name",
            "text": "",
            "title": "cmp_ok( this, op, that [, name] )"
        },
        {
            "location": "/testmore/#type_ok-val-t-name",
            "text": "",
            "title": "type_ok( val, t [, name] )"
        },
        {
            "location": "/testmore/#pass-name",
            "text": "",
            "title": "pass( name )"
        },
        {
            "location": "/testmore/#fail-name",
            "text": "",
            "title": "fail( name )"
        },
        {
            "location": "/testmore/#require_ok-mod",
            "text": "",
            "title": "require_ok( mod )"
        },
        {
            "location": "/testmore/#eq_array-got-expected-name",
            "text": "",
            "title": "eq_array( got, expected [, name] )"
        },
        {
            "location": "/testmore/#is_deeply-got-expected-name",
            "text": "",
            "title": "is_deeply( got, expected [, name] )"
        },
        {
            "location": "/testmore/#error_is-code-params_array-expected-name",
            "text": "",
            "title": "error_is( code [, params_array], expected [, name] )"
        },
        {
            "location": "/testmore/#error_like-code-params_array-pattern-name",
            "text": "",
            "title": "error_like( code [, params_array], pattern [, name] )"
        },
        {
            "location": "/testmore/#lives_ok-code-params_array-name",
            "text": "",
            "title": "lives_ok( code [, params_array] [, name] )"
        },
        {
            "location": "/testmore/#diag-msg",
            "text": "",
            "title": "diag( msg )"
        },
        {
            "location": "/testmore/#note-msg",
            "text": "",
            "title": "note( msg )"
        },
        {
            "location": "/testmore/#skip-reason-count",
            "text": "plan(4)\n\npass \"one\"\n\nif true then\n    skip(\"here, segfault\", 2)\nelse\n    fail \"two\"\n    fail \"three\"\nend\n\npass \"four\"  gives  1..4\nok 1 - one\nok 2 - # skip here, segfault\nok 3 - # skip here, segfault\nok 4 - four",
            "title": "skip( reason [, count] )"
        },
        {
            "location": "/testmore/#todo_skip-reason-count",
            "text": "plan(3)\n\npass \"one\"\n\nif true then\n    todo_skip \"here, segfault\"\nelse\n    fail \"two\"\nend\n\npass \"three\"  gives  1..3\nok 1 - one\nnot ok 2 - # TODO & SKIP here, segfault\nok 3 - three",
            "title": "todo_skip( reason [, count] )"
        },
        {
            "location": "/testmore/#skip_rest-reason",
            "text": "plan(3)\n\nif not require_ok 'MyApp' then\n    skip_rest \"no MyApp\"\n    os.exit()\nend\n\npass \"two\"\npass \"three\"  gives  1..3\nnot ok 1 - require 'MyApp'\n#     module 'MyApp' not found:\n#       no field package.preload['MyApp']\n#       no file '.\\MyApp.lua'\n#       ...\nok 2 - # skip no MyApp\nok 3 - # skip no MyApp",
            "title": "skip_rest( reason )"
        },
        {
            "location": "/testmore/#todo-reason-count",
            "text": "plan(4)\n\npass \"one\"\n\ntodo( \"not yet implemented\", 2 )\nfail \"two\"\nfail \"three\"\n\npass \"four\"  gives  1..4\nok 1 - one\nnot ok 2 - two # TODO # not yet implemented\nnot ok 3 - three # TODO # not yet implemented\nok 4 - four",
            "title": "todo( reason [, count] )"
        },
        {
            "location": "/testmore/#examples",
            "text": "-- 99example.t\n#!/usr/bin/lua\nrequire 'Test.More'\n\nplan(9)\n\nok(true, \"true\")\nok(1, \"1 is true\")\nnok(false, \"false\")\nnok(nil, \"nil is false\")\n\nis(1 + 1, 2, \"addition\")\n\nlike(\"with aaa\", 'a', \"pattern matches\")\nunlike(\"with aaa\", 'b', \"pattern doesn't match\")\n\nerror_like([[error 'MSG']], '^[^:]+:%d+: MSG', \"loadstring error\")\nerror_is(error, { 'MSG' }, 'MSG', \"function error with param\")  $ lua 99example.t\n1..9\nok 1 - true\nok 2 - 1 is true\nok 3 - false\nok 4 - nil is false\nok 5 - addition\nok 6 - pattern matches\nok 7 - pattern doesn't match\nok 8 - loadstring error\nok 9 - function error with param  Now, with  prove .  $ prove 99example.t\n99example.t .. ok\nAll tests successful.\nFiles=1, Tests=9,  0 wallclock secs ( 0.05 usr +  0.20 sys =  0.25 CPU)\nResult: PASS  If your continuous integration tool\n(for example,  Jenkins )\nrequires the JUnix XML format.  $ prove --formatter=TAP::Formatter::JUnit 99example.t\n<testsuites>\n  <testsuite failures=\"0\"\n             errors=\"0\"\n             tests=\"9\"\n             name=\"test_99example_t\">\n    <testcase name=\"1 - true\"></testcase>\n    <testcase name=\"2 - 1 is true\"></testcase>\n    <testcase name=\"3 - false\"></testcase>\n    <testcase name=\"4 - nil is false\"></testcase>\n    <testcase name=\"5 - addition\"></testcase>\n    <testcase name=\"6 - pattern matches\"></testcase>\n    <testcase name=\"7 - pattern doesn't match\"></testcase>\n    <testcase name=\"8 - loadstring error\"></testcase>\n    <testcase name=\"9 - function error with param\"></testcase>\n    <system-out><![CDATA[1..9\nok 1 - true\nok 2 - 1 is true\nok 3 - false\nok 4 - nil is false\nok 5 - addition\nok 6 - pattern matches\nok 7 - pattern doesn't match\nok 8 - loadstring error\nok 9 - function error with param\n]]></system-out>\n    <system-err></system-err>\n  </testsuite>\n</testsuites>  If your results must be stored first, and processed after.  $ lua 99example.t > 99example.tap\n$ prove --source=TAP::Parser::SourceHandler::RawTAP 99example.tap\n99example.tap .. ok\nAll tests successful.\nFiles=1, Tests=9,  0 wallclock secs ( 0.02 usr +  0.04 sys =  0.06 CPU)\nResult: PASS",
            "title": "Examples"
        },
        {
            "location": "/testbuilder/",
            "text": "Test.Builder\n\n\n\n\nReference\n\n\nThis module is the \ncore\n of the framework.\nIt allows its extensibility.\n\n\nAll libraries built with \nTest.Builder\n could work together.\n\n\nSee the module\n\nTest.LongString\n\nas a real example.\n\n\nNote : this kind of library could be tested\nwith the help of the module \nTest.Builder.Tester\n.\n\n\nExamples\n\n\nThis minimal example shows how to add a function/predicate \niszero\n.\n\n\n-- iszero.lua\nlocal tb = require 'Test.Builder'.new()  -- it's a singleton shared by all libraries\n\nfunction _G.iszero(val, name)\n    local pass = val == 0\n    tb:ok(pass, name)\n    if not pass then\n        tb:diag(\"         got: \" .. tostring(val))\n    end\nend\n\n\n\n\n-- iszero.t\nrequire 'Test.More'\nrequire 'iszero'\n\nplan(1)\n\nval = 0\niszero(val, \"val is zero\")\n\n\n\n\n$ lua iszero.t\n1..1\nok 1 - val is zero",
            "title": "Test.Builder"
        },
        {
            "location": "/testbuilder/#testbuilder",
            "text": "",
            "title": "Test.Builder"
        },
        {
            "location": "/testbuilder/#reference",
            "text": "This module is the  core  of the framework.\nIt allows its extensibility.  All libraries built with  Test.Builder  could work together.  See the module Test.LongString \nas a real example.  Note : this kind of library could be tested\nwith the help of the module  Test.Builder.Tester .",
            "title": "Reference"
        },
        {
            "location": "/testbuilder/#examples",
            "text": "This minimal example shows how to add a function/predicate  iszero .  -- iszero.lua\nlocal tb = require 'Test.Builder'.new()  -- it's a singleton shared by all libraries\n\nfunction _G.iszero(val, name)\n    local pass = val == 0\n    tb:ok(pass, name)\n    if not pass then\n        tb:diag(\"         got: \" .. tostring(val))\n    end\nend  -- iszero.t\nrequire 'Test.More'\nrequire 'iszero'\n\nplan(1)\n\nval = 0\niszero(val, \"val is zero\")  $ lua iszero.t\n1..1\nok 1 - val is zero",
            "title": "Examples"
        },
        {
            "location": "/socketoutput/",
            "text": "Test.Builder.SocketOutput\n\n\n\n\nReference\n\n\nThis module allows to redirect the test output (\nstdout/stderr\n)\nto a \nsocket\n.\n\n\nThis feature is useful for embedded development\nwhere the test runs into a target but the output is consumed by a host.\n\n\nThe use with the \nCorona SDK\n is described in this\n\nblog\n.\n\n\nThis module requires\n\nLuaSocket\n.\n\n\nExamples\n\n\nrequire 'Test.More'\nrequire 'socket'\nlocal conn = socket.connect(host, port)\nrequire 'Test.Builder.SocketOutput'.init(conn)\n-- now, as usual\nplan(...)\n...",
            "title": "Test.Builder.SocketOutput"
        },
        {
            "location": "/socketoutput/#testbuildersocketoutput",
            "text": "",
            "title": "Test.Builder.SocketOutput"
        },
        {
            "location": "/socketoutput/#reference",
            "text": "This module allows to redirect the test output ( stdout/stderr )\nto a  socket .  This feature is useful for embedded development\nwhere the test runs into a target but the output is consumed by a host.  The use with the  Corona SDK  is described in this blog .  This module requires LuaSocket .",
            "title": "Reference"
        },
        {
            "location": "/socketoutput/#examples",
            "text": "require 'Test.More'\nrequire 'socket'\nlocal conn = socket.connect(host, port)\nrequire 'Test.Builder.SocketOutput'.init(conn)\n-- now, as usual\nplan(...)\n...",
            "title": "Examples"
        }
    ]
}